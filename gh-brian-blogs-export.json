{
  "1357278146293" : {
    "content" : "1. 检测内容变化，自动定时保存 -- half done!\n2. 显示最终效果，可以搞个filter! -- done!\n3. 快捷保存 -- done!\n4. 登录提示 -- done...\n5. ng-cloak -- done!\n6. 编辑模式和预览模式区分 -- amazingly done!\n7. 解决标题实时同步问题 -- done\n9. 本地缓存(JS，CSS等静态文件的缓存)\n10. 一个通用的提示框，用CSS动画实现 -- done!\n11. 新增，删除 -- done!\n12. loading 效果  http://www.gbtags.com/gb/share/2779.htm --done!\n13. 权限控制 -- 验证用户的ID -- done\n14. angularfire 的$login居然不支持auth了，要考虑提交个push request -- 其实是有替换方法了，华丽变身为 $scope.blogs.$auth\n15. bug 修复，比如说从preview切换到editing 状态，编辑框为空(其实也不是为空，是状态没有及时更新)；firefox  搞下兼容吧\n16. 美化代码展示\n17. 全屏出现工具条\n\n![这真的是张图片](http://www.joelonsoftware.com/items/2013/07/22invent-thumbnail.JPG)\n",
    "index" : 1357278146293,
    "title" : "todo list",
    "who" : "kinkabrain@gmail.com"
  },
  "1357286891311" : {
    "content" : "这次开发过程中，感觉 angular 最好用的就是状态的表述。用一个变量，我可以自由地在class 之间切换。比如说preview, editing, 还有登录状态 logon，\n总之让我自己觉得切换很自由，很容易，没有之前的各种纠结。甚至可以说，不用去写JS代码，仅仅在html标签之间就可以了。所以，越来越觉得 angular\n才是真正的HTML的扩展，实践了HTML的标记语言实质！\n\n只是。。。angular 经常会出现数据同步不及时的问题，所以一个hack就是使用$timeout，timeout 还经常是万能的呀~~\n\nit really does...\n\n**原来得有主动换行**。。。\n换行是不是有点大了？要么就这这样圆顶另长长第四节别想靣 \n相映成趣中顶替鄙中要夺回在协顶替 模压 模压 换行！\n\n不是我自恋，这个网站搁置了好几个月之后，重新来用，用着还是挺爽的呀～～\n\n尽管当时写到最后已经疲劳了。。",
    "index" : 1357286891311,
    "title" : "Blog 开发感悟",
    "who" : "kinkabrain@gmail.com"
  },
  "1393076834468" : {
    "content" : "这是一个新的，新的。。。。标题就不用了吧。。。。\n\n内容可能更新不及时。。。\n\n我去。。。firefox 下速度太慢，效果太差了，而且，动画还不兼容。。。\n\n所以，让我来试试吧\n\n全屏模式下不支持实时保存？ \n**其实是支持的，只是提醒没有弹出来。层级的问题吧。**",
    "index" : 1393076834468,
    "title" : "这是一个测试页面，用测试账号可以随便修改~~",
    "who" : "tt@last.com"
  },
  "1393135297043" : {
    "content" : "## git 创建仓库\nhttps://github.com/Kinka/kernel-newbie\n\nCreate a new repository on the command line\n\ntouch README.md\n\ngit init\n\ngit add README.md\n\ngit commit -m \"first commit\"\n\ngit remote add origin https://github.com/Kinka/kernel-newbie.git\n\ngit push -u origin master\n\nPush an existing repository from the command line\n\ngit remote add origin https://github.com/Kinka/kernel-newbie.git\n\ngit push -u origin master\n\n设置http 代理： git config --add http.proxy localhost:8123\n\n查看： git config --get http.proxy\n\n使用代理 polipo\n",
    "index" : 1393135297043,
    "title" : "github 创建仓库",
    "who" : "kinkabrain@gmail.com"
  },
  "1393392991733" : {
    "content" : "*  [革命性的基于知识编程语言Wolfram发布第一个演示](http://www.36kr.com/p/209963.html)\n\n* [关于CSS3 GPU渲染 硬件加速](http://www.html5rocks.com/zh/tutorials/speed/layers/)\n\n* [使用GPS定位服务](http://www.cnblogs.com/mythou/p/3167648.html)\n\n* [html5 和 绘画](http://www.html5cn.org/article-5920-1.html)\n\n* [openssl random generator multi-thread](http://stackoverflow.com/questions/19955541/generate-elliptic-curve-key-pairs-ec-key-generate-key-in-multiple-threads-usin)\n\n* [WEB IDE brackets](http://www.iplaysoft.com/brackets.html)",
    "index" : 1393392991733,
    "title" : "有用链接",
    "who" : "kinkabrain@gmail.com"
  },
  "1393732703332" : {
    "content" : "在《android4 高级编程》里看到“近距离提醒”这个功能，挺好奇的，所以就来测试下。不过，就昨天的测试结果而言，好像定位精确度还是个硬伤？\n\n我使用的目标地点是房间里获取到的一个坐标，然后检测范围是1米（估计这个精确度是肯定无法达到的），那么在房间里，当然是会触发的，触发了\n一次。但是昨天下午出去，在翻身站的时候，它居然也能够触发？而且是entering 的状态。还好，我只感觉到触发了一次。不过，我觉得在我上下班\n的场景的话，几百米的误差也还是可以接受的。\n\n然后，说回这个GPS定位的问题。试了好久，怎么发现，如果是GPS_PROVIDER的话，监听事件是不会触发onLocationChanged这个事件的。看到\n的一些解释，说是这个事件在传入的坐标相同的时候是不会触发的。这当然也可以理解。只是，我连第一次坐标都无法获取得到哦？再者，使用了\nrequestSingleUpdate来注册事件想获取当前坐标也是不行的，但是用NETWORK_PROVIDER的话果断是没有问题滴。\n\n那我就怀疑是自己的手机GPS有问题？再找找资料，那可能就是因为自己没有在空旷的地方了，接受不到卫星的信号。\n\n接着，我又注册另外一个事件 locationManager.addGpsStatusListener(statusListener); 这下子我是能够收到GPS卫星相关事件的回调，然后能够获取\n得到当前有信号的卫星数目这样子的数据，那说明GPS是没问题的。所以，接下来就是打算在户外的时候，能否工作了。\n\n贴下相关的代码：\n\n\tString provider = LocationManager.GPS_PROVIDER;\n\n    int t = 1000;     // milliseconds\n    int distance = 0; // meters\n\n    LocationListener myLocationListener = new LocationListener() {\n\n      public void onLocationChanged(Location location) {\n        // Update application based on new location.\n    \t  info.append(\"location changed: \" + location.getLatitude() + \", \" + location.getLongitude() + \"\\n\");\n      }\n\n      public void onProviderDisabled(String provider){\n        // Update application if provider disabled.\n    \t  info.append(\"provider disabled!\\n\");\n      }\n\n      public void onProviderEnabled(String provider){\n        // Update application if provider enabled.\n    \t  info.append(\"provider enabled!\\n\");\n      }\n\n      public void onStatusChanged(String provider, int status,\n                                  Bundle extras){\n        // Update application if provider hardware status changed.\n    \t  info.append(\"status changed: \" + provider + \", status: \" + status);\n      }\n    };\n    GpsStatus.Listener statusListener = new GpsStatus.Listener() {\n\t\t\n\t\t@Override\n\t\tpublic void onGpsStatusChanged(int event) {\n\t\t\tGpsStatus status = locationManager.getGpsStatus(null);\n\t\t\tGetGPSStatus(event, status);\n\t\t}\n\t};\n    locationManager.requestLocationUpdates(provider, t, distance, myLocationListener);\n    locationManager.addGpsStatusListener(statusListener);\n\t\n    private void GetGPSStatus(int event, GpsStatus status) {\n\t  switch (event) {\n\tcase GpsStatus.GPS_EVENT_SATELLITE_STATUS:\n\t\tint maxSatellites = status.getMaxSatellites();\n\t\tIterator<GpsSatellite> it = status.getSatellites().iterator();\n\t\tint count = 0;\n\t\twhile (it.hasNext() && count <= maxSatellites) {\n\t\t\tGpsSatellite s = it.next();\n\t\t\tcount++;\n\t\t}\n\t\tint offset = info.getMeasuredHeight() - scroll.getMeasuredHeight();\n\t\tif (offset > 3000) {\n\t\t\tinfo.setText(\"\");\n\t\t\toffset = 0;\n\t\t}\n\t\tif (offset < 0) offset = 0;\n\t\tscroll.scrollTo(0, offset);\n\t\tinfo.append(\"卫星数目：\" + count + \" offset: \"+offset+\"\\n\");\n\t\tbreak;\n\tcase GpsStatus.GPS_EVENT_STARTED:\n\t\tinfo.append(\"GPS_EVENT_STARTED\\n\");\n\t\tbreak;\n\tcase GpsStatus.GPS_EVENT_STOPPED:\n\t\tinfo.append(\"GPS_EVENT_STOPPED\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n  \t}\n  ",
    "index" : 1393732703332,
    "title" : "GPS 定位练习",
    "who" : "kinkabrain@gmail.com"
  },
  "1394116192327" : {
    "content" : "作为一名前端开发人员，我安装了以下插件：\n\nBracketHighlighter：用于高亮成对符号（引号、括号、标签）的工具。\n\nColor Picker（不是Color Pick）：取色器。\n\nDocBlockr：生成特定格式的函数注释。只要在函数上面一行输入“/**”，按Tab就OK了。\n\nGBK Encoding Support：对GBK编码文件的支持，中文开发者必备。\n\nSidebarEnhancements：增强侧栏文件列表的右键菜单。\n\nTag：编写HTML的时候可以自动闭合标签。\n\nTortoise：在侧栏文件列表的右键菜单中，增加Tortoise软件（TortoiseSVN、TortoiseGit、TortoiseHg）的命令。安装此插件后，可能需要修改Tortoise软件的路径。如果路径不正确，则右键菜单中不会出现Tortoise命令。\n\nZencoding：这个应该不用多说了，快速编写HTML的工具。\n\n**tail -f /var/log/kern.log 达到的功能就是 dmesg | tail -f**\n",
    "index" : 1394116192327,
    "title" : "有用段落",
    "who" : "kinkabrain@gmail.com"
  },
  "1420727106206" : {
    "content" : "2015年第一个记录。\n\n我的计划是，每周在这里写点东西。内容不限，只重坚持。\n\n居然。。。好久没更新！ 我觉得夏天可以多去溜冰～\n\n没想到竟然也坚持不了多久\n\nubuntu 增加用户\n\n\tuseradd -m -s /bin/bash kinka #创建home目录\n\tsudo usermod -a -G sudo kinka #添加到sudo用户组\n\t\nandroid:windowSoftInputMode=\"adjustResize\" 这个属性是控制软键盘弹出来时，系统对activity的大小如何控制，adjustResize 就是会改变页面大小，为键盘腾出空间。",
    "index" : 1420727106206,
    "title" : "2015/01/08",
    "who" : "kinkabrain@gmail.com"
  },
  "1421552225088" : {
    "content" : "翻译自quora http://www.quora.com/How-can-I-get-better-as-a-programmer\n\n**1. 有自己的一些个人项目**\n\n个人项目的范围可以从使用ninja框架的一个web服务，到捣鼓自己的游戏、操作系统等。最基本的，就是你可以找找日常生活中观察到的问题然后想想怎么用技术解决它们。\n\n至于你能解决什么问题的一些建议，就是可以浏览下黑客马拉松的项目，比如说PennApps, MHacks 上面就有相当不错的想法。最开始作为一个学习过程，项目的想法不用太复杂。但是到最后，你应该能够大概知道对于一个给定的问题需要用什么技术来解决。比如说，你想要设计一个类似Facebook的社交网络，你首先会想到这个项目的数据模型。在这个例子中，无向图通常就是个不错的模型，用来描述一组对象之间的关系。然后，你还会有不同的选择去实现这个图。最好就要研究下什么数据库适用于哪种场景。最后你会发现关系数据库就是个不错的选择，或者如果你对新技术感兴趣的话(好吧，每个人都应该是)\n，还可以试下图数据库([graph database](http://en.wikipedia.org/wiki/Graph_database))。\n\n**2. 持续提高计算机科学基础和问题解决能力**\n\n最后，不想你是计算机科学家，软件工程师，或者两者都是，解决问题的能力和计算机科学的基础都是非常重要的。给出一些未曾遇到过的问题，你能够基于你已所学计算机科学的知识去解决，对于软件工程师和计算机科学研究者而言都是非常必要的。在这方面有不少很好的平台。\n\n比如解决问题的：[Brilliant | Math and science explanations, examples, and practice problems. ](http://brilliant.org/)\n\n比如写代码的：UVa Online Judge, ICPC live archive, TopCoder, CodeForce, CodeChef, Leetcode, Hackerrank, HackerEarth, Project Euler\n\n**3. 投入到一些开源项目中**\n\n我想，多看看别人的代码以及其它优秀工程师是如何解决自己感兴趣的问题，是非常有效的。你可以从中学到优秀的代码惯例，如何着手处理某个特定问题以及如何跟其它人协同工作。在github上有一大堆 的开源项目。随便拉一个你感兴趣的，然后捣鼓它，做些改进然后给项目提交补丁。好的修改会得到注意然后你提交的补丁就会被加入下个修订版本。\n\n**4. 参加一些有趣的CS课程**\n\n如何互联网给了我们很多的资源，比如说Coursera 提供的免费在线课程可以让你获得证书。除了这些视频课程，也有很多相应的任务可以帮助提高你感兴趣领域的技术能力。有人收集了一些很好的计算机课程的任务和考试的列表，[https://github.com/prakhar1989/awesome-courses](https://github.com/prakhar1989/awesome-courses)。也许列表有些长，有很多事情需要去做。但是我是真心相信，如果有人真的跟着这些任务做了，他们最后一定会成为很优秀的程序员、软件工程师或者研究者的。\n\n译者 Kinka\n2015/01/18\n",
    "index" : 1421552225088,
    "title" : "译: 怎样成为一个更好的程序员？",
    "who" : "kinkabrain@gmail.com"
  },
  "1421562320695" : {
    "content" : "- 选择专业的词\n    - 如get可以进一步具体为fetch或download，size可具体为树的高度或者节点数等；\n    - 找到更有表现力的词；\n- 避免像tmp和retval这样泛泛的名字\n名字应该描述变量的目的或者它所承载的值。\n    - tmp做临时存储时也有其意义；只用于短期存在且临时性为主要存在因素的变量；tmp有时作为名字的一部分会更好，如tmp_file；\n    - 循环迭代器；可以使用i, j和it等，但有时会有更贴切的命名，如club_i, members_i, users_i或ci, mi, ui等；\n- 用具体的名字代替抽象的名字\n- 为名字附带更多信息\n    - 带单位的值，如elapsed_ms；\n    - 附带其他重要属性\n    如果这是一个需要理解的关键信息，那就将它放在名字里；\n- 名字应该有多长\n    - 在小的作用域里可以使用短的名字；\n    - 输入长名字的时候可以利用编辑器自动补全的功能；\n    - 首字母缩略词和缩写：原则是新成员能否理解这个名字的含义？\n    - 丢掉没用的词；\n    - 利用名字的格式来传递含义，如常量、类成员变量等；",
    "index" : 1421562320695,
    "title" : "把信息封装到名字里",
    "who" : "tt@last.com"
  },
  "1421562588293" : {
    "content" : "VIM 复制内容到系统剪贴板\n\n需要vim-gtk 的支持 sudo apt-get install vim-gtk\n\n可以查看是否已经支持 vim --version | grep clip\n\n+clipboard       +iconv           +path_extra      +toolbar\n+eval            +mouse_dec       +startuptime     +xterm_clipboard\n\n然后用鼠标选中内容之后输入 \"+y 即可复制到系统剪贴板，更方便点，设置快捷键 vnoremap <C-c> \"+y 这样子就可以使用Ctrl+C 了！",
    "index" : 1421562588293,
    "title" : "VIM 复制内容到系统剪贴板",
    "who" : "tt@last.com"
  },
  "1422761858300" : {
    "content" : "需要申请个shadowsocks 账号，付费的\n\n然后在本地配置转发，从而在浏览器上可以使用插件，或者系统上使用socks5 代理\n\nSwitchyProxy 使用 https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt ，可以自动更新自动代理的规则，比较省事，不用每次自己去设置，挺好的。\n\n\timport socks\n\timport socket\n\tsocks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, \"127.0.0.1\", 18087)\n\tsocket.socket = socks.socksocket\n\timport urllib2\n\tprint urllib2.urlopen('http://www.google.com').read()\n\n通过使用rinetd 做端口转发，可以无障碍收发gmail邮件了！比如说：\n\n\t/etc/rinetd.conf:\n\t0.0.0.0 9993 imap.gmail.com 993\n\t0.0.0.0 4465 smtp.gmail.com 465\n\trinetd 运行之\n\nthunderbird 中imap 和 smtp 服务器的相关配置改成对应的本地地址和端口即可。如提示证书错误，确认即可。\n\n可是，后来又发现系统代理设置不了，不走socks代理的话仍然不行。所以，尝试使用了下proxychains, 确实是简单得多了。\n\t\n\tsudo apt-get install proxychains\n\tsudo vim /etc/proxychains.conf \n\tappend: socks 127.0.0.1 18087\n\tproxychains thunderbird\n\t\ndone!\n\n\nandroid studio 中无法使用socks代理下载android sdk的，它只支持http代理，所以无法从dl-ssl.google.com 这个网站上下载SDK。不过，刚发现有个polipo的web cache proxy，它可以轻易地把socks 代理转化成http代理。其实就是让polipo走socks代理啦。ubuntu 下可直接apt-get install. \n\npolipo 配置： /etc/polipo/config\n\n\tsocksParentProxy = \"0.0.0.0:1028\"#把后面的1028改成刚刚配置的shadowsocks本地端口\n\tsocksProxyType = socks5 #shdadowsocks为socks5代理\n",
    "index" : 1422761858300,
    "title" : "使用shadowsocks 翻墙",
    "who" : "kinkabrain@gmail.com"
  },
  "1426122486081" : {
    "content" : "[Linus：利用二级指针删除单向链表](http://coolshell.cn/articles/8990.html)\n\n遍历单向链表，并根据给定判断函数来决定是否删除某个节点，一般写法如下：\n```\ntypedef struct node {\n    struct node *next;\n    /* ... */\n} node;\n\n/* Function to decide if we need to delete a node */\ntypedef bool (* remove_fn)(node const *v);\n\nnode *remove_if(node *head, remove_fn rm)\n{\n    for (node *prev = NULL, *curr = head; curr != NULL;) {\n        node * const next = curr->next;\n        if (rm(curr)) {\n            if (prev)\n                prev->next = next;\n            else\n                head = next;\n            free(curr);\n        } else\n            prev = curr;\n        curr = next;\n    }\n    return head;\n}\n```\nLinux认为这是不懂指针用法的做法。我们可以有效地利用二级指针来操作链表，从而使得代码更简洁。\n```\nvoid remove_if(node **head, remove_fn rm)\n{\n    for (node **curr = head; *curr;) {\n        node *entry = *curr;\n        if (rm(entry)) {\n            *curr = entry->next;\n            free(entry);\n        } else\n            curr = &entry->next;\n    }\n}\n```\n现在，curr是一个指向next指针的指针，当前要处理的节点是next指针指向的那个节点。另外，这里相当于把head指针也当作一个dummy头节点的next指针，因此可以统一处理所有节点而无需分情况讨论。删除节点的实质是要修改某些节点的指针域，因此我们可以通过指针的指针来直接完成，而无需再引用节点。",
    "index" : 1426122486081,
    "title" : "利用二级指针删除单向链表.md",
    "who" : "tt@last.com"
  },
  "1426122540865" : {
    "content" : "# Description\nGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nFor example,\nGiven 1->4->3->2->5->2 and x = 3,\nreturn 1->2->2->4->3->5.\n\n***\n# Solutions\n# Solution 1\n直接维护两个新的链表即可。\n```\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode *partition(ListNode *head, int x) {\n        ListNode *lesser, *greater, *i, *j;\n        i = j = lesser = greater = NULL;\n        ListNode *node = head;\n        while (node != NULL) {\n            if (node->val < x) {\n                if (!i) {\n                    i = node;\n                    lesser = i;\n                } else {\n                    i->next = node;\n                    i = node;\n                }\n            } else {\n                if (!j) {\n                    j = node;\n                    greater = j;\n                } else {\n                    j->next = node;\n                    j = node;\n                }\n            }\n            node = node->next;\n        }\n        if (!lesser && greater) {\n            lesser = greater;\n        }\n        if (i) {\n            i->next = greater;\n        }\n        if (j) {\n            j->next = NULL;\n        }\n        return lesser;\n    }\n};\n```\n\n## Solution 2 根据Linux的二级指针优化\n```\nclass Solution {\npublic:\n    ListNode *partition(ListNode *head, int x) {\n        ListNode *lesser = NULL, *greater = NULL;\n        ListNode *cur = head;\n        ListNode **pl = &lesser, **pg = &greater;\n \n        while (cur) {\n            if (cur->val < x) {\n                *pl = cur;\n                pl = &((*pl)->next);\n            } else {\n                *pg = cur;\n                pg = &((*pg)->next);\n            }\n            cur = cur->next;\n        }\n        *pl = greater;\n        *pg = NULL;\n        return lesser;\n    }\n};\n```",
    "index" : 1426122540865,
    "title" : "Partition List",
    "who" : "tt@last.com"
  },
  "1426568987044" : {
    "content" : "国内无法使用谷歌，对于IT人员来讲是一个大问题，本文总结了在国内使用谷歌的方法。\n\n1、提供谷歌搜索结果的网站\n\n\t谷粉搜搜  http://www.gfsoso.com/\n\t谷搜客   https://www.gusouk.com/\n\tFqGoogle  http://www.fqgoogle.com/\n以上网站都直接提供谷歌搜索结果。\n\n2、提供谷歌IP的网站\nhttp://www.xiexingwen.com/m.php 搜索后会自动跳转到一个可用的Google IP，读者可以使用这个IP，修改Hosts文件，就可以直接访问谷歌了。\n\n3、上谷歌的Android App\n\n\t爱谷搜   http://gusou.bmob.cn/\n唯一一个提供使用谷歌搜索服务的Android App，方便手机用户使用谷歌。\n\n4、翻墙工具\n\n\tGoAgent https://github.com/goagent/goagent\n\tGreatAgent  http://code.google.com/p/greatagent/wiki/downloads\n以上为常用的两个翻墙工具\n\n5. npm 代理设置\n\t\t\n\t\tkinka@uKinka:~$ npm config set proxy http://127.0.0.1:8123\n\t\tkinka@uKinka:~$ npm config set https-proxy http://127.0.0.1:8123\n\n",
    "index" : 1426568987044,
    "title" : "翻墙",
    "who" : "tt@last.com"
  },
  "1426744785265" : {
    "content" : "1. 登录框即使获取输入焦点了，但是只要把鼠标移开，就会自动隐藏，即使你仍然可以输入；\n2. 登陆时输入用户名和密码后不能使用enter键来登录。",
    "index" : 1426744785265,
    "title" : "反馈建议",
    "who" : "tt@last.com"
  },
  "1427988206510" : {
    "content" : "第一步，安装cordova... 没想到本来很简单的，却纠结了很久，严重影响了进度。\n\nsudo apt-get install nodejs (因为nodejs不叫node，所以 \n\n\tsudo update-alternatives --install /usr/local/bin/node node /usr/bin/nodejs 10 \n进行别名链接)，需要注意的是，cordova 还不能用最新的nodejs, ubuntu 自带的那个版本就可以了 0.10.23\n然后安装npm，npm 可以顺便更新到最新\n\n\tsudo npm install npm -g\n\n顺便的话  sudo npm install cordova -g 应该 就能安装完成了，问题就是不顺利的话就会有更种千奇百怪的问题，比如版本不对应呀，依赖不对呀等等。。。\n\n还有，代理的问题，最后反而是取消了代理成功安装的。有使用代理的情况下，出现内容被截断了！\n\n",
    "index" : 1427988206510,
    "title" : "Keep In Touch",
    "who" : "kinkabrain@gmail.com"
  },
  "1431876747678" : {
    "content" : "React DOM 的几个重要术语(概念)：https://facebook.github.io/react/docs/glossary.html#react-components\n\n\tReactElement\n\tReactNode\n\tReactComponent/ReactComponent Class\n\n\ttype ReactElement = ReactComponentElement | ReactDOMElement;\n\nReactDOMElement 就简单理解为React对常见标签(div/ul等)的封装，而ReactComponentElement则是自定义标签。\n\nReactComponet Class 就是一个javascript class，用于声明自定义标签的实现。Class的实例就是一个ReactComponent。\n而这个实例过程最好由React来负责，即调用React.createElement接口完成，得到一个ReactComponentElement。\n\n接下来就是将虚拟DOM添加真实DOM树中，完成展示，即调用React.render()完成。\n\nReact.render() 返回的是一个ReactComponent实例，比如：\n\n\tvar componentA = React.render(<MyComponent />, document.body);\n\t\n\n\n\n\n\n",
    "index" : 1431876747678,
    "title" : "React.js 学习",
    "who" : "kinkabrain@gmail.com"
  }
}
